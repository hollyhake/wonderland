[["index.html", "Tracking memory decline 1 Introduction 1.1 Rate of Forgetting", " Tracking memory decline Holly Hake 2022-07-27 1 Introduction The goal of this project is to track memory decline in Alzheimers disease and dementia using the model-based, adaptive SlimStampen system. Memory loss is a debilitating symptom of neurodegenerative diseases. Current assessment tools, however, lack the reliable, convenient, and repeatable qualities needed to capture the individualized and evolving nature of memory decline. This project uses neurocomputational models to track and predict memory decline in subjectively- or mildly-cognitively impaired (MCI) individuals. MCI = Functional capacity is relatively intact, but on objective testing, show cognitive decline in at least one area of neuropsychological functioning. 1.1 Rate of Forgetting Rate of forgetting is the probability of retrieving a particular memory over time and is rooted in a Bayesian model of cognition. "],["methods.html", " 2 Methods 2.1 Participants 2.2 Memory Task", " 2 Methods 2.1 Participants A total of 25-50 English-speaking participants aged between (#) and (#) years old were recruited on a rolling basis from the Alzheimers Disease Research Center (ADRC). Participants were enrolled for one year to get a comprehensive view of how their memory changes over time. All participants provided informed consent and were compensated with $100 for their participation in the online memory game portion of the study. All of the recruitment and testing procedures were approved by the University of Washingtons Institutional Review Board. 2.2 Memory Task Rate of forgetting was estimated using SlimStampen, an adaptive fact learning system (AFLS) described in Sense et al.Â (2016). "],["results.html", " 3 Results 3.1 Accuracy 3.2 Rate of Forgetting 3.3 Response Time 3.4 Rate of Forgetting Distribution 3.5 Statistics 3.6 Classification accuracy", " 3 Results Lets calculate the repetition, activation, and alpha for each fact. Then, lets average alpha. To do this, we need to identify the terminal alpha value of each fact, that is, the estimate of alpha at for the very last repetition. After that, we will filter the data so that it only contains the first full session (some participants like completing the task more than once). # Calculate avg alpha data_lastRep &lt;- data %&gt;% group_by(lessonId, userId, sessionId, factId) %&gt;% mutate(LastRepetition = max(repetition)) %&gt;% filter(repetition == LastRepetition) %&gt;% ungroup() data_avg1 &lt;- data_lastRep %&gt;% group_by(userId, lessonTitle, lessonId, sessionId) %&gt;% summarise(Meanalpha=mean(alpha), Medianalpha=median(alpha)) data_avg2 &lt;- data %&gt;% group_by(lessonId, userId, sessionId) %&gt;% summarise(correct = mean(correct), responseTime=mean(reactionTime)) %&gt;% ungroup() data_avg &lt;- data_avg1 %&gt;% inner_join(data_avg2) data_avg %&gt;% group_by(userId, lessonTitle, lessonId) %&gt;% summarize(numSess=length(unique(sessionId))) ## # A tibble: 71 x 4 ## # Groups: userId, lessonTitle [71] ## userId lessonTitle lessonId numSess ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 69410 01 Practice 4035 1 ## 2 69410 Birds 3322 1 ## 3 69410 European Capitals 1 3257 1 ## 4 69410 Flowers 3255 1 ## 5 69410 Newspapers 3321 1 ## 6 69410 Pasta 3266 1 ## 7 69410 Swahili 1 3254 1 ## 8 69411 Birds 3322 1 ## 9 69411 European Capitals 1 3257 2 ## 10 69411 Flowers 3255 1 ## # ... with 61 more rows ## # i Use `print(n = ...)` to see more rows # Filter the sessions sessionData &lt;- data %&gt;% group_by(userId, sessionId, lessonId, lessonTitle) %&gt;% summarize(duration = (max(presentationStartTime) - min(presentationStartTime))/60000, start = min(presentationStartTime), legit = if_else(duration &gt; 6, T, F)) sessionData &lt;- sessionData %&gt;% group_by(userId, lessonId, lessonTitle) %&gt;% arrange(start, by_group=T) %&gt;% mutate(sessionRank = seq(1, length(start))) sessionDataFiltered &lt;- sessionData %&gt;% filter(legit == T) %&gt;% group_by(userId, lessonId) %&gt;% mutate(minRank = min(sessionRank)) sessionData &lt;- sessionData %&gt;% inner_join(sessionDataFiltered) %&gt;% mutate(usable = if_else(minRank == sessionRank, T, F)) # Group by clinical status clinical &lt;- inner_join(data_avg, groups) %&gt;% inner_join(sessionData) %&gt;% filter(usable == T) clinical %&gt;% group_by(lessonTitle, clinicalStatus) %&gt;% summarise(n=length(userId)) %&gt;% pivot_wider(names_from=clinicalStatus, values_from = n) %&gt;% xtable() %&gt;% kable(digits = 3) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;)) lessonTitle Control MCI 01 Practice 3 3 Birds 4 5 European Capitals 1 4 5 Flowers 5 4 Newspapers 5 6 Pasta 5 6 Swahili 1 4 4 clinical$userId &lt;- as.character(clinical$userId) clinical &lt;- clinical %&gt;% mutate(paired= factor(userId)) # Order the lessons by week #level_order&lt;- factor(clinical$lessonTitle, level = c(&#39;01 Practice&#39;,&#39;Pasta&#39;,&#39;Swahili 1&#39;,&#39;Flowers&#39;,&#39;European Capitals 1&#39;,&#39;Birds&#39;, &#39;Newspapers&#39;)) # Delete practice clinical &lt;- clinical[!(clinical$lessonTitle==&quot;01 Practice&quot;), ] level_order&lt;- factor(clinical$lessonTitle, level = c(&#39;Pasta&#39;,&#39;Swahili 1&#39;,&#39;Flowers&#39;,&#39;European Capitals 1&#39;,&#39;Birds&#39;, &#39;Newspapers&#39;)) 3.1 Accuracy The averaged accuracy for each participant across all lessons. This graph lets you interact with the data points to get a better look at the accuracy scores for each of the individual participant. This graph separates the participants by clinical status. 3.2 Rate of Forgetting 3.2.1 Mean Rate of Forgetting The mean Rate of Forgetting for each participant across all lessons. As you can see, individuals with Mild Cognitive Impairment (MCIs) tend to have a higher Rate of Forgetting than the age-matched controls. 3.2.2 Median Rate of Forgetting The median Rate of Forgetting for each participant across all lessons. As you can see, individuals with Mild Cognitive Impairment (MCIs) tend to have a higher Rate of Forgetting than the age-matched controls. 3.3 Response Time The averaged response time for each participant across all lessons. This graph lets you interact with the data points to get a better look at the Response Time scores for each of the individual participant. This graph separates the participant by clinical status. 3.4 Rate of Forgetting Distribution First, lets examine the distribution of ROF values for MCIs and controls, either across all sessions (A) or averaged across all sessions (B). clinical_avg &lt;- clinical %&gt;% group_by(userId, clinicalStatus) %&gt;% summarise(RoF = mean(Meanalpha)) p1 &lt;- ggplot(clinical, aes(x=Meanalpha, fill=clinicalStatus)) + geom_density(alpha=0.4, col=&quot;white&quot;, bw=0.02) + scale_fill_manual(values = c(&quot;gold3&quot;, &quot;purple3&quot;)) + xlab(&quot;Mean Rate of Forgetting&quot;) + ggtitle(&quot;RoF Distributions\\n(single sessions)&quot;) + ylab(&quot;Number of Observations&quot;) + xlim(c(0.2, 0.6)) + labs(fill=&quot;Clinical Status&quot;) + theme_pander() + theme(legend.position = &quot;bottom&quot;) p2 &lt;- ggplot(clinical_avg, aes(x=RoF, fill=clinicalStatus)) + geom_density(alpha=0.4, col=&quot;white&quot;, bw=0.03) + scale_fill_manual(values = c(&quot;gold3&quot;, &quot;purple3&quot;)) + xlab(&quot;Mean Rate of Forgetting&quot;) + ggtitle(&quot;RoF Distributions\\n(averaged)&quot;) + ylab(&quot;Number of Observations&quot;) + xlim(c(0.2, 0.6)) + labs(fill=&quot;Clinical Status&quot;) + theme_pander() + theme(legend.position = &quot;bottom&quot;) ## This is a function from the &#39;cowplot&#39; package plot_grid(p1, p2, labels=c(&quot;A&quot;, &quot;B&quot;), ncol = 2, nrow = 1) 3.5 Statistics An ANOVA using the mean ROF as the dependent variable. m1 &lt;- aov(Meanalpha ~ (lessonTitle * clinicalStatus) + Error(userId/lessonTitle), clinical) m1 %&gt;% tidy() %&gt;% xtable() %&gt;% kable(digits = 4) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;hover&quot;)) stratum term df sumsq meansq statistic p.value userId lessonTitle 5 0.0112 0.0022 0.2610 0.9166 userId clinicalStatus 1 0.0218 0.0218 2.5501 0.1712 userId lessonTitle:clinicalStatus 2 0.0093 0.0046 0.5419 0.6124 userId Residuals 5 0.0428 0.0086 NA NA userId:lessonTitle lessonTitle 5 0.0172 0.0034 5.6901 0.0007 userId:lessonTitle lessonTitle:clinicalStatus 5 0.0036 0.0007 1.1968 0.3322 userId:lessonTitle Residuals 33 0.0199 0.0006 NA NA 3.6 Classification accuracy 3.6.1 Single session How well can we tell patients from controls based on their ROF value from a single session? curve &lt;- NULL mlclinical &lt;- clinical %&gt;% #group_by(userId,clinicalStatus) %&gt;% #summarize(Meanalpha=mean(Meanalpha), Medianalpha = median(Meanalpha)) %&gt;% mutate(observed = ifelse(clinicalStatus == &quot;MCI&quot;, -1, 1)) for (threshold in seq(0.2, 0.8, 0.01)) { subthreshold &lt;- mlclinical %&gt;% mutate(prediction = ifelse(Meanalpha &lt;= threshold, 1, -1)) %&gt;% mutate(accuracy = ifelse(prediction == observed, 1, 0)) %&gt;% group_by(observed) %&gt;% summarise(accuracy = mean(accuracy)) tnr &lt;- subthreshold %&gt;% filter(observed == -1) %&gt;% dplyr::select(accuracy) %&gt;% as.numeric() tpr &lt;- subthreshold %&gt;% filter(observed == 1) %&gt;% dplyr::select(accuracy) %&gt;% as.numeric() partial &lt;- tibble(Threshold = threshold, TNR = tnr, TPR = tpr) if (is.null(curve)) { curve &lt;- partial } else { curve &lt;- rbind(curve, partial) } } And now, we can visualize the ROC graph. First, we can compute the global AUC AUC &lt;- 0 step &lt;- 0.01 for (tnr in seq(0, 1, step)) { y &lt;- curve %&gt;% filter (TNR &lt;= tnr) %&gt;% filter(TNR == max(TNR)) %&gt;% summarise(TPR = mean(TPR)) %&gt;% as.numeric() AUC &lt;- AUC + (y * step) } The global AUC is 0.7931687. Then, we can visualize the ROC curve and see the classification accuracy at each RoF threshold: curve &lt;- curve %&gt;% mutate(auc = (TPR + TNR)/2) ggplot(arrange(curve, TPR), aes(x=TNR, y=TPR)) + geom_point(size=2, col=&quot;purple&quot;, alpha=0.5) + geom_line(col=&quot;purple&quot;) + geom_text_repel(aes(label=paste(&quot;RoF =&quot;, Threshold, &quot;\\n AUC =&quot;, percent(auc, .2))), col=&quot;black&quot;, #position=position_stack(vjust=0.5), direction=&quot;both&quot;, size=3) + ylab(&quot;Sensitivity (True Positive Rate)&quot;) + xlab(&quot;Specificity (True Negative Rate)&quot;) + scale_x_reverse() + ylim(0, 1) + xlim(1, 0) + coord_equal() + ggtitle(&quot;ROC Curve for Different Thresholds&quot;) + geom_abline(slope=1, intercept = 1, col=&quot;grey&quot;, linetype = &quot;dashed&quot;) + theme_pander() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
